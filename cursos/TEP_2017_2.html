<html>

  <head>
    <script type="text/javascript" src="../language.js"></script>

    <meta http-equiv="Content-Type"
     content="text/html; charset=ISO-8859-1"><link type="text/css" rel="stylesheet"
     href="../estilo.css"><title>Vin&iacute;cius Gusm&atilde;o Pereira de S&aacute;</title>

  </head> 
  
  <body onload="autoLanguage()">  

    <h2>T&oacute;picos Especiais em Programa&ccedil;&atilde;o  &#8212;  &nbsp;2017/2</h2>


    <p class="en"><a href="..">Main page</a><br>
    <p class="pt"><a href="..">P&aacute;gina principal</a><br>
                  
    <div><h3>Informa&ccedil;&otilde;es</h3></div>
    
    <ul>
     
       <li>   <div>Local: LEP-2<br>
                        Hor&aacute;rio: sextas das 13h &agrave;s 17h<br>
                        In&iacute;cio: 04 de agosto de 2017<br>
                        
                        <br>
       <li>                 Reposit&oacute;rio: <br><a target="_blank" href="https://github.com/vigusmao/TEP_2017_2">https://github.com/vigusmao/TEP_2017_2</a>
                       <br><br>
       
                       

                       </font>
                       
   </ul>                     
                      


<div><h3>Conte&uacute;do das aulas</h3></div>
    
    
<h4><font color="blue">04/08</font></h4>
<br>
Conversa introdut&oacute;ria.<br>
	  <a target="_blank" href="google_interview_tips.pdf">Carta do Google</a> com dicas para entrevistas.<br>
	  Visualizando por que a notação O(.) faz sentido. Constantes multiplicativas e aditivas que realmente não importam. 
	  Código no <a target="_blank" href="https://github.com/vigusmao/TEP_2017_2/blob/master/complexity.py">GitHub</a>.<br><br>
	  
	  <b>Trabalho 1</b>: o problema de se encontrar números ao mesmo tempo quadrados e triangulares. Ex.: 36=6*6 e 36=1+2+3+4+5+6+7+8.
	  Escreva um programa para listar os primeiros <em>n</em> inteiros com essa propriedade.
	  

	&nbsp;<br>
	&nbsp;<br>
	
	
<h4><font color="blue">11/08</font></h4>
<br>
Heaps binárias (revisão). <br>
	  Esperança de variável aleatória. Complexidade de caso médio. O caso médio do QuickSort 
	  (assumindo distribuição uniforme das permutações dos <em>n</em> elementos que se quer ordenar).<br><br>
	  
	  O problema da selação dos <em>k</em> maiores (ou menores) elementos de uma lista.<br>
	  Abordagem 1: ordena tudo e retorne os <em>k</em> primeiros.<br>
	  Abordagem 2: mantém os <em>k</em> maiores já vistos em uma lista (array) não-ordenado.<br>
	  Abordagem 3: mantém os <em>k</em> maiores já vistos em uma lista (array) ordenado.<br>
	  Abordagem 4: mantém os <em>k</em> maiores já vistos em uma lista encadeada ordenada.<br>
	  Abordagem 5: mantém os <em>k</em> maiores já vistos em uma heap de mínimo (de tamanho <em>k</em>).<br>
	  Abordagem 6: QuickSelect.<br><br>
	  
	  <b>Trabalho 2</b>: implementar o QuickSelect e pelo menos duas das outras abordagens, comparando-as para diversos valores de <em>n</em> e <em>k</em>.
	  
	  
	  

	&nbsp;<br>
	&nbsp;<br>
	  
	  
<h4><font color="blue">18/08</font></h4>
<br>
Bitwise operations. O problema de se determinar a menor potência de 2 que é maior ou igual ao número dado.<br>
Novo exemplo de uso eficiente de uma heap: ordenando um array cujos elementos estão originalmente no máximo 
à distância <em>k</em> da posição que ocuparão no array ordenado.<br><br>
Introdução às classes P e NP. O Problema do Milênio.

	&nbsp;<br>
	&nbsp;<br>
	
	
<h4><font color="blue">25/08</font></h4>
<br>
	  Sorteando <em>k</em> elementos sem repetição, com uniformidade, em tempo <em>O(k)</em>. 
Várias abordagens pouco eficientes. O paradigma do colecionador de coupons. Linearidade da esperança. Knuth shuffle (Fisher-Yates shuffle).<br><br>
Problema: listar todas as permutações dos <em>n</em> primeiros inteiros positivos.<br><br>	

Discussão geral sobre backtracking. Implementação do problema proposto em Python. <br>
Código feito em sala de aula no <a target="_blank" href="https://github.com/vigusmao/TEP_2017_2/blob/master/permutacoes.py">GitHub</a>.
<br><br>

<b>Trabalho 3</b>: listar todos os anagramas da palavra PARALELA, onde:<br>
- a primeira letra é uma consoante; e<br>
- as letras R e P não aparecem juntas (em qualquer ordem); e<br>
- a primeira ocorrência de um L fica à direita da primeira ocorrência de um A.<br>
	  Reportar a quantidade de anagramas listados, no final.

	  &nbsp;<br>
	&nbsp;<br>
	  
<h4><font color="blue">01/09</font></h4>
<br>
Problemas envolvendo hashing.<br><br>
	  Problema 1: Dada uma lista com <em>n</em> inteiros e um inteiro <em>k</em>, encontrar os pares de elementos distintos da lista que somem <em>k</em>.
	  <br>
	  Problema 2: Dadas duas listas, encontrar sua interseção.<br>
	  Problema 3: Dada uma lista de inteiros e uma função <em>f</em> nos inteiros, encontrar todas as tuplas de elementos distintos
	  (<em>x, y, z, w</em>) que satisfaçam <em>f(x) + f(y) = f(z) + f(w)</em>.<br><br>
	  
	  Memoização. Memoização com limitação de memória (políticas de cache).<br><br>
	  
	  <b>Trabalho 4</b>: Seja <em>f(x) = x/2</em>, se <em>x</em> é par; e <em>f(x) = 3x+1</em>, se <em>x</em> é ímpar. 
	  Seja <em>g(x)</em> o número de vezes que deve-se aplicar a função <em>x</em>, a partir de <em>x</em>, até que o resultado obtido seja 1. 
	  Exemplo: g(10) = 6, correspondendo à sequência 10 - 5 - 16 - 8 - 4 - 2 - 1.
	  Entrada do programa: dois inteiros, <em>min_x</em> e <em>max_x</em>. Saída: <em>x</em> e <em>g(x)</em>, para <em>x</em> que maximiza a função <em>g</em>, 
	  com <em>min_x &le; x &le; max_x</em>.

	&nbsp;<br>
	&nbsp;<br>	
	  
	  
<h4><font color="blue">15/09</font></h4>
<br>
	  <b>Trabalho 5</b>: Seja <em>X<sub>n,k</sub></em> uma variável aleatória definida como o número de vezes que se deve sortear
	  (com reposição) uma <em>k</em>-upla de elementos distintos de <em>A</em> = {1, 2, ..., <em>n</em>} até que todas as <em>k!</em>
	  permutações de <em>algum</em> subconjunto de <em>A</em> já tenham sido sorteadas. 
	  Entrada do programa: um inteiro <em>n</em> e um inteiro <em>k</em>. 
	  Saída: uma boa aproximação para a esperança de <em>X<sub>n,k</sub></em>, obtida por simulação.<br><br>
	  
	  Discussão sobre uso eficiente de memória. Como armazenar as tuplas sorteadas poupando espaço. <br>
	  Problema incidental: dada uma tupla de <em>k</em> elementos, como saber sua posição na lista de todas as permutações
	  (daqueles <em>k</em> elementos) ordenadas lexicograficamente?

	&nbsp;<br>
	&nbsp;<br>

		<p>
        <a href=#><img title="Voltar ao topo" style="height: 35px" src="../seta_voltar.jpeg" alt="Voltar ao topo" ></a>
        </p>
		
  </body>

</html>
