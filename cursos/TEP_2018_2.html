<html>

  
<head>
    <script type="text/javascript" src="../language.js"></script>

    <meta http-equiv="Content-Type"
     content="text/html; charset=ISO-8859-1"><link type="text/css" rel="stylesheet"
     href="../estilo.css"><title>Vin&iacute;cius Gusm&atilde;o Pereira de S&aacute;</title>

  </head> 
  
  <body onload="autoLanguage()">  

    <h2>T&oacute;picos Especiais em Programa&ccedil;&atilde;o  &#8212;  &nbsp;2018/2</h2>


    <p class="en"><a href="..">Main page</a><br>
    <p class="pt"><a href="..">P&aacute;gina principal</a><br>
                  
    <div><h3>Informa&ccedil;&otilde;es</h3></div>
    
    <ul>
     
       <li>   <div>Local: Sala F2-033 (no dia 17/08) e Sala do Futuro 1 (restante do curso)<br>
                        Hor&aacute;rio: sextas das 13h &agrave;s 17h<br>
                        In&iacute;cio: 17 de agosto de 2018<br>
                        Avaliações: trabalhos feitos em sala de aula (e possivelmente terminados em casa, a combinar)
                        
                        
                        <br>
       <li>                 Reposit&oacute;rio: <br><a target="_blank" href="https://github.com/vigusmao/TEP_2018_2">https://github.com/vigusmao/TEP_2018_2</a>
                       <br>
                       Problemas recomendados: <a href="http://hackerrank.com" target="_blank">hackerrank</a>

                       <br><br>
                       
                            
       
                       

                       </font>
                       
   </ul>                     
                      


<div><h3>Conte&uacute;do das aulas</h3></div>
    
    
<h4><font color="blue">17/08</font></h4>
<br>
	  Conversa inicial sobre o curso. <a href="http://vigusmao.github.io/cursos/google_interview_tips.pdf" target="_blank">Google Interview Preparation Tips.</a><br>
	  Complexidade assintótica: por que é imporante? <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/complexity.py" target="_blank">por que</a> as constantes são desprezíveis?<br> 
	  Complexidade O(sqrt(n))? Exemplo de sqrt-decomposition: o problema do edifício e das duas bolas idênticas.<br>
	  O problema dos números que estão faltando no array. Código (Python 3) feito em sala de aula no <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/numero_faltando.py" target="_blank">GitHub</a>.
	  
	  &nbsp;<br>
	  &nbsp;<br>
    
<h4><font color="blue">24/08</font></h4>
<br>
	  A <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/loops_aninhados.c" target="_blank">complexidade de nested loops</a>.<br>
	  Número harmônico. O problema dos armários. A <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/QSR.txt">complexidade do Quick Sort Randomizado</a>.<br>
	  Algoritmos com complexidades distintas que <em>coexistem</em> como boas opções. Um pode ser mais eficiente do que o outro, dependendo da entrada.<br>
	  <br>
	  Trabalho 1: O <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/lifespan.txt" target="_blank">problema do lifespan</a>. 
	  
	  
	  	  
	  &nbsp;<br>
	  &nbsp;<br>
    
<h4><font color="blue">14/09</font></h4>
<br>
	  Mais problemas que admitem algoritmos distintos que "competem" entre si. 
	  Exemplo: o <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/estradas.txt">problema das estradas</a>.<br>
	  Sorteando números sem reposição. Knuth shuffle (aka Fischer-Yates shuffle).<br>
	  O <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/tuane_shuffle.py">"Tuane Shuffle"</a>, em que sorteamos k inteiros positivos sem repetição, do intervalo [1, n], para n dado, em tempo e espaço O(k).
	  
	  <br>
	  Backtracking. O <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/perm_caoticas.txt">problema das permutações caóticas</a>. 
	  <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/perm_caoticas.py">Solução em Python</a>. Note que há dois commits. 
	  No primeiro, temos a versão de enumeração, que lista todas as permutações; no segundo, temos a versão que encontra apenas uma.<br>
	  <br>
	  Trabalho 2: Encontre todos os subconjuntos de tamanho k do conjunto {1, 2, 3, ..., n}, para n e k dados.
	  
	  &nbsp;<br>
	  &nbsp;<br>
    
<h4><font color="blue">21/09</font></h4>
<br>
	  <a hreaf="https://github.com/vigusmao/TEP_2018_2/blob/master/subconjuntos.py">Solução conjunta</a> do problema dos subconjuntos. Enumeração via bitwise operations.<br>
	  O <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/numeros_magicos.txt">problema dos números mágicos</a>. 
	  Cuidado com casos que aparentemente te levam a um backtracking, mas que são muito mais fáceis em verdade.
	  <br>
	  O problema do array "quase ordenado". Recordando listas encadeadas, árvores binárias de busca e heaps.<br>
	  <br>
	  Problemas do hackersrank:<br>
	  <a href="https://www.hackerrank.com/challenges/ctci-ransom-note/problem">Ransom Note</a>. <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/ransom_note.py">Minha solução.</a><br>
          <a href="https://www.hackerrank.com/challenges/sherlock-and-anagrams/problem">Sherlock and Anagrams</a>. <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/sherlock_and_anagrams.py">Minha solução.</a><br>
	  <br>
	  Trabalho 3: Imprima todos os anagramas de uma palavra dada (qualquer) que:<br>
     a) começam por vogal; e<br>
     b) não tem três consoantes juntas; e<br>
     c) a primeira ocorrência da letra "P", se houver, tem que ocorrer antes da primeira ocorrência da letra "G", se houver; e<br>
     d) não tem duas letras iguais consecutivas.
	  
	    
	  &nbsp;<br>
	  &nbsp;<br>
    
<h4><font color="blue">28/09</font></h4>
<br>
	  Dividir e conquistar.<br>
	  Relações de recorrência.<br>
	  Recursão.<br>
	  Memoização.<br>
	  Programação Dinâmica. <br>
	  <br>
	  O problemas das permutações caóticas <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/perm_caoticas_recursao.py">via relação de recorrência com memoização</a>.<br>
	  O <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/mochila.py">problema da mochila</a> via "PD top down", i.e., usando memoização para não resolver subproblemas repetidos.<br>
	  PS.: Desabilitem a memoização e vejam o que acontece com os tempos!
	  <br><br>
	  Trabalho 4: O <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/balsas.txt">problema da carga da balsa</a>.
	     Resolva por backtracking ingênuo, depois pense em como se livrar da complexidade exponencial (no número <em>n'</em>de carros que cabem na balsa)
	  usando PD/memoização, chegando a uma complexidade pseudo-polinomial do tipo <em>O(L * n')</em>.
	  
	  

	  &nbsp;<br>
	  &nbsp;<br>
    
<h4><font color="blue">05/10</font></h4>
<br>
	  Memoização quando não sabemos de antemão a quantidade de subproblemas a memoizar. Políticas de cache.<br>
	  O problema do 3n+1 (Conjectura de Collatz). Código no <a href="https://github.com/vigusmao/TEP_2018_2/blob/master/3nplus1.py">GitHub</a>.<br><br>
	  A força de um único bit. O problema dos condenados encapuzados.<br><br>
	  Trabalho 5: Dada uma lista de palavras válidas, encontrar uma matriz bidimensional de caracteres 
	  que possua área máxima e na qual cada linha e coluna corresponda precisamente a uma palavra válida 
	  (i.e., um "retângulo mágico"). 
	  
	
	  &nbsp;<br>
	  &nbsp;<br>
    
<h4><font color="blue">05/10</font></h4>
<br>
	  Tries. Test-driven development (TDD).<br>
	  Resolução do exercício do retângulo mágico, sem o uso de tries (e sem usar TDD) e com o uso de tries (programadas com TDD). 
	  Código no <a href="https://github.com/vigusmao/TEP_2018_2/tree/master/RetanguloPalavras/src">GitHub</a>.
	  <br><br>
	  Trabalho 6A: Seja uma moeda com probabilidade p=2/3 de dar cara num cara-ou-coroa. Encontre, computacionalmente (via simulação):<br>
	  - o número médio de lançamentos da moeda até obter 5 caras;<br>
	  - o número médio de lançamentos da moeda até obter 2 caras <em>seguidas</em>, e isso por duas vezes independentemente.<br>
	 O que acontece quando você varia p?<br><br>
	  
	  Trabalho 6B: Seja um dado não necessariamente honesto de n faces. Encontre, computacionalmente (via simulação):<br>
	  - a probabilidade de se obter três resultados iguais em três lançamentos seguidos do dado;<br>
	  - a probabilidade de se obter dois pares seguidos em 4 lançamentos do dado, i.e., A=B, C=D.<br>
	 O que acontece quando você varia a distribuição de probabilidades do dado?
	  
	    
	  

		<p>
        <a href=#><img title="Voltar ao topo" style="height: 35px" src="../seta_voltar.jpeg" alt="Voltar ao topo" ></a>
        </p>
	  
		
  </body>

</html>
